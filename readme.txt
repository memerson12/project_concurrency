Michael Emerson - memerson
Vishnu Priya Dendukuri - vdendukuri

Our implementation uses the Hillis Steele Algorithm to sum all of the numbers. Before we initialize the thread, we create two arrays called ‘elements’ and ‘psums’ that contain the values of the imputed vectors. These arrays will be shared between all threads. In addition to these arrays, our threads share the number of threads completed so far, the number of elements, the number of threads, and the offset which is the number of digits each thread should calculate the sum of. This offset is calculated by dividing the element count by the number of threads, then, if the number of elements divided by the thread count isn’t a whole number adding 1 to the offset ((element_count / thread_count) + (element_count % thread_count == 0 ? 0 : 1)). In addition to these shared variables, each thread is assigned an individual thread id from 0 to the total number of threads minus 1. We then execute the parallel scan function with the specified number of threads. Each thread will then do a for loop starting at their thread id multiplied by the offset until their thread id multiplied by the offset plus the offset. This ensures each thread only operates on its set of data and since the elements and psums arrays are shared these can be run concurrently. In this for loop, I check if the current position minus 2^current step is a valid index of the array. If it is, elements at that index plus elements at the current index and store it in the psums array. We then use a two-phase barrier to wait for all of the threads to finish the current step of the operation. Once all threads have reached the barrier, we increase the step by one then check if 2^local steps would be greater than the element count. If it would be, we exit the thread. If we don’t exit, in a lock we check if we are the first thread to get to this point and if so, copy the values of the psums array to the elements array for the next step. We then unlock and allow the process to repeat until all threads exit. To coordinate threads this design uses a two-stage barrier created using semaphores. This barrier ensures all the threads reach the necessary point before continuing while still allowing them to be run concurrently.